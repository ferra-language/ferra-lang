# Ferra Diagnostics Design v0.1

This document specifies the design for Ferra's v0.1 diagnostic reporting system. Diagnostics include errors, warnings, and informational messages generated by the compiler front-end (lexer, parser, type checker, borrow checker, etc.).

## 1. Introduction & Goals

*   **Purpose**: To provide users with clear, actionable, and human-friendly feedback about their code, enabling them to understand and fix issues efficiently.
*   **User Experience**: Diagnostics are a critical part of the developer experience. They should be helpful, not frustrating.
*   **Consistency**: Maintain a consistent style and structure for all diagnostic messages.
*   **Tooling Integration**: Design with IDEs and AI-assisted explanation tools (like `ai::explain(err)`) in mind.
*   **Accessibility**: Colorized ANSI output by default for terminals that support it; should automatically fall back to plain ASCII when `FERA_NO_COLOR=1` is set or the TTY is not detected. A `--color=<when>` flag (e.g., `auto`, `always`, `never`) should also be available. (Note: v0.1 diagnostic messages will be English-only; localization is a future consideration tracked as ⚠️ **TBD (DIAG-L10N-1)**).

## 2. Guiding Principles for Diagnostics

*   **"Positive-First" Messaging**: As emphasized in `docs/Steps.md` and other design documents, diagnostics should, where possible:
    *   First state what *is* valid or what the compiler *did* understand.
    *   Then, clearly indicate the point of error or conflict.
    *   Finally, offer concrete, actionable hints or suggestions for fixing the issue.
*   **Clarity & Conciseness**: Messages should be easy to understand, avoiding overly technical jargon where simpler terms suffice. Be direct but not blunt.
*   **Accuracy**: Pinpoint the exact source location(s) relevant to the issue.
*   **Actionability**: Whenever possible, suggest one or more likely ways to resolve the error.
*   **No Blame**: Phrase messages constructively, avoiding accusatory language.
*   **AI-Explainability**: Structure diagnostics so they can be effectively processed and elaborated upon by the `ai::explain(err)` API (see §10).

## 3. Diagnostic Message Structure & Schema

A diagnostic message, when processed and stored internally, should conform to a canonical schema. This allows for consistent handling, rendering, and machine-readable output.

```jsonc
// Conceptual JSON Schema for a Diagnostic Object
{
  "severity": "Error" | "Warning" | "Note" | "Help" | "Info", // Required
  "code": "E0077", // Example: Optional but recommended stable ID (see §3.1)
  "message": "Primary human-readable message for the diagnostic.", // Required
  "primary_span": { "file_id": 0, "lo": 420, "hi": 427 }, // Required: Main source location (see AST_SPECIFICATION.md §9 for Span)
  "labels": [ // Optional: Array of secondary spans with messages
    {
      "span": { "file_id": 0, "lo": 380, "hi": 388 },
      "message": "e.g., previous definition was here"
    }
  ],
  "notes": [
    "Optional longer explanatory paragraph.",
    "Another note providing more context."
  ],
  "hints": [
    "Optional actionable suggestion on how to fix.",
    "Or, consider this alternative approach."
  ],
  "stage": "Lexer" | "Parser" | "TypeChecker" | "BorrowChecker" | "CodeGen" // Optional: Compiler stage originating the diagnostic
  // "rendered_text": "... pre-rendered ANSI or plain text ..." // Optional: Cached rendered output
}
```

*   **Severity**: `Error`, `Warning`, `Note`, `Help`, `Info`.
    *   Errors typically prevent compilation.
    *   Warnings indicate potential issues but do not stop compilation (unless `-D warnings` or similar is active).
*   **Code**: A unique, stable identifier. See §3.1.
*   **Message**: The primary human-readable summary.
*   **Primary Span**: The main source code location.
*   **Labels**: Additional contextual spans with their own messages.
*   **Notes**: Extended explanations.
*   **Hints**: Actionable suggestions.
*   **Stage**: Originating compiler phase (useful for debugging the compiler itself).

### 3.1. Diagnostic Codes

*   A system of unique diagnostic codes (e.g., `E0001` for an error, `W0020` for a warning) **SHOULD** be used.
*   These codes help in:
    *   Unambiguously identifying specific issues.
    *   Allowing users to search for detailed explanations or suppress specific warnings.
    *   Stability for tooling that might parse or react to specific diagnostics.
*   A central registry or document (e.g., `docs/diagnostic_codes.md` - ⚠️ **TBD (DIAG-CODES-DOC-1)**) will list all codes, their meanings, and example triggers.
*   **Conceptual Code Ranges for v0.1**:
    | Category              | Code Range        | Notes                       |
    |-----------------------|-------------------|-----------------------------|
    | Lexer Errors          | `E0001` - `E0019` |                             |
    | Parser Errors         | `E0020` - `E0049` |                             |
    | Type System Errors    | `E0050` - `E0089` |                             |
    | Borrow Checker Errors | `E0090` - `E0099` | Placeholder for v0.1 scope  |
    | Warnings (all stages) | `W0001` - ...     |                             |

### 3.2. Tooling JSON Output Format (for VSCode Plugin Alpha & Similar Tools)

To ensure compatibility with tooling like the VSCode Alpha Plugin (as specified in `docs/VSCODE_PLUGIN_ALPHA_SPEC.md`), the Ferra compiler, when outputting diagnostics in a machine-readable JSON format (e.g., via a `--diagnostics-format=jsonline` flag), will adhere to the following:

1.  **One JSON Object Per Line**: Each diagnostic message will be a single, self-contained JSON object, output on its own line.
2.  **JSON Object Structure**: Each JSON object will contain the following fields:
    *   `severity`: (string) One of `"error"`, `"warning"`, or `"note"`. (The internal richer severities like `Help` or `Info` should be mapped to one of these for this output format, typically `note`).
    *   `message`: (string) The primary human-readable message for the diagnostic.
    *   `file_path`: (string) The absolute path to the source file where the diagnostic originates.
    *   `span`: (object) An object defining the primary source location with byte offsets:
        *   `lo`: (integer) Start byte offset (0-indexed).
        *   `hi`: (integer) End byte offset (exclusive).
    *   `code`: (string, optional) The stable diagnostic code (e.g., `"E0077"`).
    *   `help`: (string, optional) A brief actionable suggestion or link to further documentation. This corresponds to the first or a summary of the internal `hints` array.
    *   `labels`: (array of objects, optional) For secondary locations related to the diagnostic. Each label object should contain:
        *   `span`: (object) `{ "lo": int, "hi": int }` for the secondary location.
        *   `message`: (string) A message specific to this secondary location.

This JSON line protocol provides a standardized way for external tools to consume and interpret Ferra compiler diagnostics.

## 4. Source Code Context Rendering

*   Diagnostics should display relevant snippets of the source code.
*   The primary span should be clearly marked (e.g., with `^^^^` and a primary color like red for errors).
*   Secondary spans (labels) should also be marked (e.g., with `----` and a secondary color or different style).
*   Line numbers should be displayed, typically in a gutter.
*   Multi-line spans should be handled gracefully.
*   **Color Usage**: Use ANSI colors in terminals by default. Provide a mechanism to disable color:
    *   Environment variable: `FERRA_NO_COLOR=1`.
    *   Command-line flag: e.g., `--color=never` (alongside `auto`, `always`).
*   The rendering should adapt to the available width and be clear in both color and monochrome.

```text
// Conceptual Rendered Output (from scaffold, enhanced):
error[E0077]: mismatched types
  --> src/main.ferra:5:10
   |
4  |     let x: Int = "hello";
   |         -   --- this annotation implies `x` should be an `Int`
   |         |
   |         ...but this expression was found to be of type `String`
   |
5  |     if x > "world" { ... }
   |            ^^^^^^^ `>` operator here cannot compare `Int` with `String`
   |
   = note: Values of type `String` cannot be directly compared with `Int` values using the `>` operator.
   = help: If `"world"` is meant to be a number, try converting it using a function like `String::to_int()` (hypothetical).
   = help: Or, change the type annotation of `x` if it is intended to be a `String`.
```

## 5. Lexer Diagnostics

(Refers to `DESIGN_LEXER.md`, §9)
*   **Common Errors**: Invalid character, unterminated string/comment, invalid numeric literal format (if not deferred to parser), indentation errors (e.g., dedent to unexpected level).
*   **Example Message (Invalid Character)**:
    ```text
    error: invalid character `#` in source file
      --> src/main.ferra:3:5
       |
    3  | let val # = 10;
       |         ^
       |
       = help: Remove the invalid character or replace it if it was a typo.
    ```

## 6. Parser (Syntax) Diagnostics

(Refers to `DESIGN_PARSER.md`, §9)
*   **Common Errors**: Unexpected token, mismatched delimiters, expected X found Y. For parser error recovery and synchronization tokens, see `DESIGN_PARSER.md` §9.
*   **Example Message (Unexpected Token)**:
    ```text
    error: unexpected token `else` found after if condition
      --> src/main.ferra:7:1
       |
    6  | if x > 0 
       |          - expected a block `{...}` or an indented block here
    7  | else { ... }
       | ^^^^ unexpected `else`
       |
       = note: The `if` condition must be followed by a consequence block.
       = help: Wrap the statements after the `if` condition in `{...}` or indent them.
    ```
*   **Hygiene Errors** (e.g., mixed brace/indent for a block) should also be reported by the parser or a very early AST validation pass.

## 7. Type System Diagnostics

(Refers to `DESIGN_TYPE_INFERENCE.md`, §7)
*   **Common Errors**: Type mismatch, unresolved type variable, occurs check (infinite type), trait bound not satisfied (future), lifetime errors (future).
*   **Pretty-Printing Type Variables**: As per `DESIGN_TYPE_INFERENCE.md`, internal type variables (`α`, `β`) **MUST NOT** be shown directly. They should be replaced with placeholders like `_` or descriptive names (e.g., `inferred_type_of_x`).
*   **Example Message (Type Mismatch)**:
    ```text
    error: mismatched types
      --> src/main.ferra:4:18
       |
    3  | fn add(a: Int, b: Int) -> Int { a + b }
       |                      --- expected `Int` due to function return type
    4  | let result: String = add(1, 2);
       |             ------   ^^^^^^^^ expected `String` because of type annotation
       |             |
       |             found type `Int` from call to `add`
       |
       = note: Expected type `String` but expression has type `Int`.
       = help: Ensure the function `add` returns a `String`, or change the type annotation of `result`.
    ```

## 8. Message De-duplication & Throttling

(As per `docs/Steps.md`)
*   To avoid overwhelming the user with cascaded errors, a mechanism like a **Bloom filter** (or simpler heuristic) should be used to limit the number of diagnostics reported per source line (e.g., target ≤ 3 messages/line). The specific design details for this, including key generation for de-duplication, Bloom filter properties/alternatives, and the interaction with per-line counters, are further elaborated in `docs/FRONTEND_ENHANCEMENTS.md` (Section 3).
*   The compiler **MUST** stop after a maximum of 50 errors per file (or a similar global limit) to prevent excessive output and long compilation times on broken code. (The exact mechanism and configurability of this limit is ⚠️ **TBD (DIAG-THROTTLE-1)**, though `docs/FRONTEND_ENHANCEMENTS.md` provides a more detailed design for the de-duplication and throttling logic).

## 9. Machine-Readable Output (Future Consideration)

*   While human-readable output is primary, providing diagnostics in a machine-readable format like **JSON** (based on the schema in §3 and specifically the tooling output format in §3.2) or **SARIF** is highly beneficial for IDE integration and other tooling.
*   A command-line flag like `--diagnostics-format=jsonline` should enable this. (This resolves the ⚠️ **TBD (DIAG-CLI-JSON-1)** for the v0.1 target format and basic flag name; exact schema for other formats like full SARIF remains future work).
*   The diagnostic data structure defined in §3 is designed to facilitate such serialization.
*   The stability of error codes (if used) and the richness of primary/secondary span information will be key to effective AI explanations.
*   The data payload provided to such an API is further detailed in `docs/FRONTEND_ENHANCEMENTS.md` (Section 4).

## 10. Integration with `ai::explain(err)`

*   The structured diagnostic information (severity, code, message, spans, labels, notes, hints) will serve as rich input to the `ai::explain(err)` API.
*   The AI can use this structured data to:
    *   Provide more detailed, context-aware natural language explanations of the error.
    *   Offer alternative fixing strategies or code examples.
    *   Link to relevant documentation or learning resources.
*   The stability of error codes (if used) and the richness of primary/secondary span information will be key to effective AI explanations.
*   The data payload provided to such an API is further detailed in `docs/FRONTEND_ENHANCEMENTS.md` (Section 4).

## 11. Open Questions & Future Enhancements (Diagnostics Specific)

*   **(DIAG-CODES-DOC-1)** Create and maintain the `docs/diagnostic_codes.md` document.
*   **(DIAG-L10N-1)** Strategy for localization (L10N) of diagnostic messages (v0.1 is English-only).
*   **(DIAG-CLI-CONFIG-1)** User configuration for diagnostic verbosity, warning levels (e.g., `-Werror`), and specific warning suppression/promotion via CLI flags and/or a configuration file.
*   **(DIAG-RECOVERY-1)** How diagnostic reporting interacts with parser/type-checker error recovery mechanisms (e.g., reporting suppressed errors or recovery attempts).
*   **(DIAG-THROTTLE-1)** ~~Define exact implementation mechanisms and potential configurability for error throttling.~~ Basic mechanisms are defined; further specifics on configurability are TBD. See `docs/FRONTEND_ENHANCEMENTS.md` for more design detail on de-duplication.
*   **(DIAG-CLI-JSON-1)** Finalize CLI flag and exact schema for machine-readable diagnostic output.
*   Detailed specification for the data payload and interaction model for `ai::explain(err)`. (See `docs/FRONTEND_ENHANCEMENTS.md` (Section 4) for current design details on payload and flow).
*   Integration with a potential Language Server Protocol (LSP) implementation.
*   User-configurable themes/colors for diagnostic output (⚠️ **TBD (DIAG-STYLE-1)**).
*   Diagnostics for macro expansion and hygiene (⚠️ **TBD (DIAG-MACRO-1)**). 